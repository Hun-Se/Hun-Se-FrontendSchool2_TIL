# JavaScript

<details>
<summary><b>5월 3일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 3일 개념 정리

### 배열

- 데이터의 집합. 여러개의 값을 하나의 이름으로 묶어 사용할 수 있게 도와준다.
- 배열의 각 값은 원소(element) 혹은 요소 라고 부른다.
- 배열의 크기는 length 프로퍼티를 통해 알 수 있다.
- 배열의 생성자 함수에 숫자를 한개만 넣으면 인스턴스의 길이를, 여러 숫자를 넣으면 배열의 원소를 뜻한다.
  예)

  ````JavaScript
  Array(5);
  // (5) [비어 있음 × 5] 길이가 5임을 알수있다.
  Array(1,5);
  //(2) [1, 5] 배열에 1과 5가 할당되었다.

      ```

  ````

- 배열에도 리터럴 표현이 있다.( [ ] )
- 각괄호 + 인덱스를 통해 각 원소에 접근 할 수 있으며, 원소에 값을 저장 할 수도 있다. 심지어 존재하지 않는 원소에도 접근이 가능하다.
- 리터럴 생성과 동시에 원소에 접근 할 수 있다.

```JavaScript
([1,2,3,][0] === 1)
```

### 배열 제어

1. pop() :

- 배열에서 마지막 요소를 제거하고 그 요소를 반환한다.
- 제거 한 요소를 보관하고 싶다면 변수에 담아 둘 수 있다.
- 빈 배열에 pop을 호출하면 undefined를 호출한다.
  <br>

2. push() :

- 배열의 마지막 요소로 인자로 전달한 값을 추가하고 새로운 배열의 길이를 반환한다.
  <br>

3. splice() :

- 기존의 요소를 삭제하거나, 교체하거나, 새 요소를 추가한다.
- 인덱스, 카운트, 아이템 순서로 인자를 전달한다.
  <br>

4. slice() :

- 두 개의 인자를 전달하여 배열안에 있는 요소를 새로운 배열로 반환한다.
- 원본 요소는 바뀌지 않는다.
  <br>

5. sort() :

- 배열의 요소를 정렬한 후 그 배열을 반환한다.
- 문자형은 오름차순으로 정렬된다.
- 숫자형은 유니코드로 변환된 값으로 오름차순 정렬된다.
- 비교함수를 사용하여 오름차순, 내림차순으로 정렬 할 수 있다.

</div>
</details>

<details>
<summary><b>5월 10일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 10일 개념정리

1. Babel: ECMAScript 2015+ 코드를 이전 JavaScript 엔진에서 실행할 수 있는 이전 버전과 호환되는 JavaScript 버전으로 변환하는 데 주로 사용되는 무료 오픈 소스 JavaScript 트랜스컴파일러이다.

- 트랜스파일러: 구 표준을 준수하는 코드로 변경하게 해준다.

- 폴리필: 새롭게 도입되는 문법들을 브라우져에서 사용가능하도록 바뀌어 주는것 최신표준을 준수할 수 있게 작업할 수 있다.

2. 일반적인 객체 리터럴, { key : value } 를 가진 객체는 반복 가능한 객체가 아니기 때문에 for of문을 쓰면 에러가 발생한다.

3. Object.entries() 메서드는 for...in와 같은 순서로 주어진 객체 자체의 enumerable 속성 [key, value] 쌍의 배열을 반환한다.

4. 구조 분해할당 참고사이트: https://ko.javascript.info/destructuring-assignment

5. Math.max()에는 배열을 넣을 수 없다.

6. `let {name2, age2, height2} = {name2:'hojun', height2:'20', age2:'10'}`에서 객체는 순서에 상관없이 변수명에 따라 매칭된다.

7. new Date()는 브라우져에 세계별로 다른 시간이 내장 되어있기 떄문에 다크모드를 구현 할때 유용하게 사용된다.

8. d.getYear() 은 1900년도부터 연도 계산한다. 사용하지 않는다.

9. `‘’+ 10 => ’10’` 문맥에 따라 형 변환이 일어난다.

10. 파라미터는 선어할때, 아규먼트는 실행할떄 부른 명칭이다.

11. 콜백함수: argument로 넣어주는 것을 콜백함수라고 한다.

12. 즉시 실행 함수는 재사용 하지 않으려고 사용한다.

13. 재귀함수를 사용할때에는 종료조건이 있어야한다.(그렇지 않으면 무한반복이 일어난다.)

14. 동적계획법

15. call by value argument: 값이 넘어간다. / call by reference: 주소값이 넘어간다.
</div>
</details>

<details>
<summary><b>5월 11일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 11일 개념정리

1. this

- this를 사용하면 다른 객체에서도 사용가능하다.
- this가 가리키는건 고유 메모리주소이다.
- 화살표 함수의 this는 일반적인 this처럼 함수를 할당하지 않고, 바로 상위 scope에 this를 할당한다.

2. scope

- 스코프는 변수의 접근성과 휘발 유무를 제어한다.
- 전역 스코프: 스크립트 어디서든 접근이 가능하다. 충돌 가능성이 있기 때문에 사용에 주의해야 한다.
- 함수 스코프: 함수 내부에서 정의된 변수에 접근이 가능하며 매개변수는 함수 외부에서 접근 할 수 없다.

3. closure

- 폐쇄된 공간에 대한 접근 권한을 가진 함수를 말한다.

</div>
</details>

<details>
<summary><b>5월 16일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 16일 개념정리

1. object-fit

- `object-fit:cover` 이미지를 크기에 맞게 맞추지만 이미지의 손실이 날 수 있다.
- `object-fit:contain` 비율을 유지하면서 커진다.

2. screenX: 사용자의 모니터 가로기준 (만약 사용하고 있는 모니터 개수가 많으면 그 모니터값들이 더해져서 원하는 작동 방식이 이상해 질 수도 있다.)

3. clinentX 브라우져 가로기준

4. preventDefault(): 브라우져의 기본이벤트 동작을 취소 할 수 있다.

5. contextmenu: 브라우져에서 우클릭을 하면 나오는 이벤트 메뉴이다.

6. innerHTML를 사용해서 원하는 HTML요소를 생성 하고 appendChild메서드를 사용해서 만든 요소를 추가 할 수있다.

   ```HTML
   elLi.innerHTML = `<img src=${item} alt=''>`;
   center.appendChild('elLi')
   ```

7. offsetWidth 메서드를 사용해서 요소의 width값을 가져오고 이를 활용 할 수 있다.

   ```JavaScript
   const radius = items[0].offsetWidth * items.  length / 3.14 / 2;
   ```

8. transform-style:preserve-3d속성과 perspective에 값을 추가하여 요소를 3d처럼 보이게 할 수있다.

</div>
</details>

<details>
<summary><b>5월 17일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 17일 개념정리

1. 객체지향 프로그래밍: 객체는 우리가 표현하고자 하는 구체적인 사물을 추상적으로 표현한것이며, 추상화한 객체를 만들어 소통하는 것을 뜻한다.

2. 생성자: new 연산자와 함꼐 사용하며 객체는 같은 프로퍼티와 메서드를 공유할수 있다는 장점이 있다.

- 생성자 함수는 따로 return값을 가지지 않지만 new키워드가 앞에 붙게되면 실행되었을 떄 자동적으로 객체를 생성하고 반환한다.
- 반환되어 만들어진 객체를 인스턴스(intance)라고 한다.
- 생성자 함수와 객체와의 관계는 intanceof로 확인 할 수 있다. (true | false)

3. 상속: 객체간의 상속이 가능하다.

- call 함수는 상속받는 함수의 this가 상속해주는 함수의 this를 바라보게 만든다.
- Object.create 함수는 주어진 인자를 사용하는 객체에 연결하는 역할을 한다.
</div>
</details>

<details>
<summary><b>5월 18일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 18일 개념정리

1. 스코프: 스코프(유효 범위)란 해당 변수가 정의되어 있는 영역, 즉 정의된 변수를 사용할 수 있는 소스코드의 집합.

2. 스코프체인: 자바스크립트가 변수 값을 얻으려고 할 때(variable resolution, 변수 해석) 스코프 체인에서 변수를 찾는다. 스코프 체인은 위에서 말했다시피 객체의 리스트이므로, 첫 번째 객체에서 해당 변수를 찾고, 없으면 그 다음 객체(상위요소)에서 해당 변수를 찾고, 여기도 없으면 그 다음 객체에서 찾는 식이다. 리스트의 끝까지 탐색했는데도 그 변수가 없다면 reference error가 발생한다.

3. 클로져(closer): 타언어에는 있는 private 영역을, 자바스크립트에서는 클로저라는 테크닉(영역X)으로 대신한다.

4. 렉시컬 스코핑(Lexical scoping)스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다.

5. 모듈패턴: 중요한 정보는 일부러 보호하기 위해 클로저 공간으로 만드는 패턴이다.

6. 클래스의 상속: extends를 사용한다. 상속받는 클래스를 파생 클래스라고한다.

7. #키워드를 사용하면 프로프티를 비공개로 전환할 수 있다.

8. 비공개로 전환된 값에 접근하고 수정하려면 값을 불러오는 getter메서드,값을 수정하는 setter메서드라고 부른다.

</div>
</details>

<details>
<summary><b>5월 19일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 19일 개념정리

1. 테스트 주도 개발: 테스트를 통해서 개발을 안전하게 개발 하는것

2. 최적화: 빠르게 개발하는것을 선호하기 때문에 다른 작업보다 우선순위가 떨어진다. 하지만 최적화된 개발을 하면 사용자 경험이 좋아질 수 있다.

3. 성능 측정의 척도:

- 올바르게 동작하게만든다.(메모리, 네트워크 트래픽과 같은 자원을 효과적으로 사용한다.)
- 빠르게 만든다.(구동시간, 계산시간, 반응시간 등을 높인다.)

4. 구동시간 최적화:

1)  다운로드 해야하는 파일 객수와 용량을 작게 유지한다.

- 이미지 스프라이트 기법 사용하기
- 최신 포맷의 이미지를 사용하기
- 이미지 용량 최적화 툴을 사용하기
- 폰트의 사용빈도가 제한적이라면 이미지 폰트를 사용하기
- 폰트는 최신포맷을 사용하기

2.  최소화한 CSS,JS 파일을 사용하여 파일의 용량을 줄 일 수 있다. 하지만 가독성이 떨어지기 떄문에 협업을 할 때는 주의를 요해야 한다.

3.  라이브러리와 프레임워크는 필요한 것만 사용해야한다. 과도한 사용은 성능을 저하 시킬 수 있다.

4.  중요하지 않은 콘텐츠라면 레이지 로딩을 고려해볼 필요가 있다.
5.  크롬 개발자도구의 네트워크탭에서 지속적인 구동시간을 측정 할 수 있다.

5)  반응시간 최적화:

1. JS보다는 CSS 애니메이션을 활용한다.
2. Transform속성을 사용한다.(ransform을 이용한 속성은 gpu를 사용하기 떄문에 애니메이션이나 동적으로 요소의 위치를 이동하는경우 position보다 translate 속성을 이용한다.)
3. repaint, reflow를 유발하는 속성은 되도록 사용하지 않는다.
   - repaint의 경우, Visibility를 DOM API을 통해 조절했을 때 자식 노드들까지 다 검색하기 때문에 성능 저하를 일으킬 수 있다.
   - reflow는 리플로우는 해당 요소의 자식요소와 부모/조상 요소역시 레이아웃 계산을 진행하여 성증 저하를 일으킬 수 있다.
4. requestAnimationFram을 사용한다.

- 브라우저가 애니메이션을 최적화 하도록 하는 방법이다.

5. Document fragment를 사용해서 가상 돔을 만들어 추가되는 내용을 메모리상에만 저장해 놓은다. 그리고 실제 dom에 옮겨지면 메모리상에 있던 내용들은 삭제된다.

6. 메모리누수를 방지한다.
  
7. DOM트리 + CSSOM트리 = 레이아웃 트리 
화면에 표현되는 정보만 트리에 담기게 된다.

- 자바스크립트는 저수즌의 언와는 다르게 사용하지 않는 메모리는 자바스크립트 엔젠이 추정하여 삭제한다.(Garbage Collection) 하지만 이를 언제 해결해 줄지 모른는 경우이기 떄문에 메모리 관리에 신경을 써야한다.

</div>
</details>

<details>
<summary><b>5월 24일 개념정리 펼치기</b></summary>
<div markdown="1">

## 5월 24일 개념정리

1. 보안이슈

2. 예외처리, 애러처리

3. try, catch: new Error(messeage) 에러를 생성하는 생성자 함수 try로 시작 에러를 만나면 catch(e)로 출력 -> finally 출력
   아무리 프로그래밍에 능한 사람이더라도 에러가 있는 스크립트를 작성할 수 있습니다. 원인은 아마도 실수, 예상치 못한 사용자 입력, 잘못된 서버 응답 등의 수천만 가지 이유 때문일 겁니다.

에러가 발생하면 스크립트는 ‘죽고’(즉시 중단되고), 콘솔에 에러가 출력됩니다.

그러나 try..catch 문법을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 ‘잡아서(catch)’ 더 합당한 무언가를 할 수 있게 됩니다.

- 자바스크립트 에러 종류: https://ossam5.tistory.com/241

4. Ajax : 비동기 통신, 자바스크립트를 이용하여 브라우저가 서버에게 비동기적으로 데이터를 요청하고, 응답 받은 데이터를 동적으로 페이지 렌더링 하는 방식을 Ajax(Asynchronous Javascript and XML)라고 한다.

5. fetch: fetch는 비동기 네트워크 통신을 구현하기 위해 사용하는 Web API이다.(매우 중요, 프로젝트에 자주쓰임)
   fetch()는 2개의 매개변수를 가진다.

- 첫 번째 매개변수 (resource) : 필수 사항, HTTP 요청을 보낼 URL
- 두 번째 매개변수 (options) : 선택 사항, method, headers, body 등

6. HTTP 상태코드:

- 1xx (조건부 응답): 요청을 받고 작업을 계속한다.
- 2xx (성공): 클래스의 상태 코드는 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리한 상태이다.(200 중요)
- 3xx (리다이렉션 완료): 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
- 4xx (요청 오류): 클라이언트에 오류가 있는 상태이다.(403, 404 중요)
- 5xx (서버 오류): 서버가 유효한 요청을 명백하게 수행하지 못한 상태이다.

  - 참고사이트: https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

7. local storage: 웹 스토리지 객체(web storage object)인 localStorage와 sessionStorage는 브라우저 내에 키-값 쌍을 저장할 수 있게 해줍니다.페이지를 새로 고침하고(sessionStorage의 경우) 심지어 브라우저를 다시 실행해도(localStorage의 경우) 데이터가 사라지지 않고 남아있다.
   참고사이트: https://ko.javascript.info/localstorage

8. D3, Canvas, chart.js
</div>
</details>

